 LINK FOR STUDY IN HOLIDAY

 1- TESTING: https://code-maze.com/asp-net-core-testing/
 https://code-maze.com/improve-unit-tests-shouldly-dotnet/
             https://code-maze.com/unit-tests-with-fluent-assertions/
 2- VUE: https://code-maze.com/vue-js-series/
 3- AUTO MAPTER : https://code-maze.com/automapper-vs-mapster-dotnet/
 4- CQRS AND MEDIATR: https://code-maze.com/cqrs-mediatr-in-aspnet-core/
 5- UNION: https://code-maze.com/onion-architecture-in-aspnetcore/
 6- VERTICAL :https://code-maze.com/vertical-slice-architecture-aspnet-core/
 7- cURSO: https://app.pluralsight.com/library/bookmarks (SQL, GIT)
  https://app.pluralsight.com/library/courses/sql-server-2012-querying-pt1/table-of-contents
  8- LIST: https://code-maze.com/dotnet-collections/

  How to Choose Between These .NET Collections
We should have gathered by now, that the choice is pretty simple:

Do we need to execute LINQ operations on remote data sources? Use IQueryable<T>
Otherwise, do we need to add or remove items in the collection? Use ICollection<T>
Else use IEnumerable<T> for all other scenarios
When it comes to writing code in .NET (or any object-orientated language),
advice tells us to use the highest interface possible to enable the greatest flexibility. Therefore,
if possible we should always try and use IEnumerable<T>. When it comes to performance,
we cannot compare the interfaces against each other, but rather specific operations, 
so best to research those particular methods as you implement them in your application.
  /*
         SOLID:
        SRP: Single responsibility pinciple
       
        Each software module should
        What is  are responsiblity?
         
         Logging, 
         Persistence, 
         Validation, 
         Business logic

         Loose coupling
         Separation of co
         cohesive

         Classe: property, field, method
         Class--> delegate-> one thing done

        OCP: Open/Closed principle (class,method)
             extension, not changes
        LSP: Liskov substituion principle
        ISP: Interface segration principle
        DIP: Dependency inversion principle
        ---------------
        TDD
        PDD: Pain driven development
         
         
         */

        /*
         SOLID:
          1- Separação das classes e única responsabilidade
             -Class, methods(this), field, property, enum 
          2- Aberto para extensão e fechado para modificação
             -Parameters, inheritance (virtual), composition (static)/injection(constructor)
          3- Herança e relacionamento (Rectangle/Square)
             - Null check (is as)
             - C# feature, guard clause (if, exception), 
             - null object design pattern
                class default
                interface
                class normal
             - implement exception
             - subset of polymorphism
          
           switch --> abstract class
           if null --> sealed class, static class

        Class: static, abstract, selead, partial

          4- Interfcae, separte each 
             - liskov, srp, pdd
             -adpater design pattner

          5- Interface and abstract class
              -Databes, fileSystem, Email, WebAPI, Configuration, clock
              -Use: construtor arg, property, method arg
              - straty design pattern
        -inverson of contro IC
        - dependency injection DI
         */


        /*
         Null: stack , Heap
          DDD- domain driven design

          you-design the system, driven by your
           
          Architectures
          Ux-first design methodology

        Naming convention
        Extension methods

        Domain -  Domain Model - 
         
        subdomain  - Bounded context

         Classic 3-tier:
            Presentation -> Presentation
            Business -> Application,  Domain
            Data access --> Infrastructure

            Layer # Tier

            DDD: Layered architecture
            Presentation: View model(DTO) (UX)
            Application: (Use-cases): Controller
            Domain: Model , Services (Business) 
            Infrastructure: Ioc, Cache, Repositories (Persistence)
            Persitence->Security->Logging/Tracing->Inversion of Control->Caching->Networks


          UX
          Use-cases
          Business: Tx Script, Table module, momain model, CQRS, eventsourching
          Persistence: Relational, NoSql, Memory
        
          Application logic:  use cases 
           Data transfer objects
           Application service
          Domain Logic:
           Domain model
           Domian services

          Common patterns:
           TX Script
           Table module
           Domain model

         Domain  Model:
           Aggregates, Entities, Value Types, Factories
         Domain Service:
           Cross-aggregate behavior, external services, reposiories, proxies

          Values objects -> Entities
                  Aggregates

          Value Types:
          DDD: 
            Aggregates,
            Business,
            DomainEvents,
            Extensions,
            Persistence: Class data base (Relation)

           CQRS: Comand query responsability segragation
               Comand -> send request, changes DB
               Query-> return object values

         */

           //Collection
            //Lists

            /*
          1- OOP (Encapulasion, Abstraction, Inheritance,Polymorphism )
               Custom types:
               Class:
                    Fields: private
                    Variable:
                    Constructors:
                    Methods, 
                    Properties: public, protected
                    Events
                    Acess modifiers: public, private,protected
               Struct:
               Objects:
        */
Comand dotnet: dotnet -h
clean
teste
new
build


request 
           middleware(pipeline)  middleware(pipeline)  middleware(pipeline)
response

3-Tier
DDD
Microservice
Clean code
Vertical
Anion
MVC pattern
returning resources
Interacting with an API

Routing:
app.UseRouting();
app.UseEndpoints(endpoints =>
{
    endpoints.MapControllers();
});

Controllers;
    [ApiController]
    [Route("api/[controller]")]
    ControllerBase
    [HttpGet()]
Razor pages
SignalR


Status code:

Level information: 100
Lever Sucess: 200
 200 ok
 201 Created 
 204 No content

 Level Client mistake
 400 bad request
 401 unauthorized
 403 forbidden
 404 not found
 409 conflict

 Level server mistake
 500 -> Internal server error

 Return:
 JsonResult
 IActionResult


 Return types:
 Specific types
 IActionResult
 ActionResult<T>

 Scrum?
     Scrum is a framework that helps teams work together. 
     Much like a rugby team (where it gets its name)
     training for the big game, scrum encourages teams 
     to learn through experiences, self-organize 
     while working on a problem, and reflect on their wins and losses
     to continuously improve.

     Sprints: A sprint is a short, time-boxed period when a scrum team works to complete a set amount of work. Sprints are at the very heart of scrum and agile methodologies, and getting sprints right will help your agile team ship better software with fewer headaches.  
     Sprint planning: Sprint planning is an event in scrum that kicks off the sprint. The purpose of sprint planning is to define what can be delivered in the sprint and how that work will be achieved. Sprint planning is done in collaboration with the whole scrum team.
     Ceremonies: Sprint planning, Daily stand-up
     Backlogs:
     Sprint reviews:
     Standups:
     Scrum master
     Retrospectives:
     Distributed scrum:
     Roles:
     Scrum of scrums:
     Agile scrum artifacts:
     Scrum metrics
     Jira confluence scrum

 Agile: criar aptar a mudança
  1-Individuals and interactions over process and tools
  2- Working software over comprehensive documentation
  3- Customer collaboration over contract negotiation
  4- Responding to change over following a plan

  12 Principios de agile manifesto?
  -Our highest priority is to satisfy the customer,even late in development
   Agile processes harness change for the customer's competitive advantage

  -Welcome changing requirements, even late in development.

  - Deleiver working software frequently, from a couple of weeks to couple of months
   with a preference to shorter timescale
   -Business people and developers must work together daily throughout project
   - Build project arrou

 Scrum vs Agile

 Waterfall
 Plan-Design-Code-test-Realease-Review

 Passing data: Model bind
 [FromRoute]
 [FromForm]
 [FromBody]
 [FromQuery]
 //Collection
            //Lists

            /*
          1- OOP (Encapulasion, Abstraction, Inheritance,Polymorphism )
               Custom types:
               Class:
                    Fields: private
                    Variable:
                    Constructors:
                    Methods, 
                    Properties: public, protected
                    Events
                    Acess modifiers: public, private,protected
               Struct:
               Objects:
        */

         //Stack
            //Heap
            //Libary
            //Arrays
            //Type of arrray

 Services: Dependency
 Scoped:um serviço, várias instância criada
 Singleton: é apenas para base de dados quando faço uma chamada na minha API e é retulizado em todo o ciclo
 Transiton:
 Transient – created each time they’re requested from the service container
 Scoped – created once per client request and is reused within that request
 Singleton – created only once and is reused across the application’s lifetime

 /*
 Dependency Injection : Inversion of Control (IoC) principle  (Inversion of Control principle is a design pattern)
                      : Dependency Inversion Principle (D in SOLID).
 
 */
 ______________________________________________________________
 Repository patterns:


ConnectionStrings: are saved in edit in the system enviroment our computer

 .net 6 C# 10 Design Patterns (23 Patterns) - 6 hours

 Pattern types:

 1- Creational (Object), Structural (to define relations between classes or objects), Behavioral (to communicate between classes or objects)

 The gang of four

 2- Creational patterns: 5
   - Abstract Factory: N Interface 
   - Builder, (Builder design pattern and fluent builder)
            Fluent Builder Interface With Recursive Generics
   - Factory Method: Abstract or interface
   - Prototype, 
   - Singleton: (Logger() private/procted) only instance, and global, Lazy and property
                - Static Instance property(+ backing field)
                - Private or protected constructor
                - Lazy<T>

   These pattens deal with object creation
 - Abstract the object instantiation process
 - Help with making your ystem independent of hoe its objects are created, composed and represented

3- Structural patterns: 7
  - Adapter - 4 SOLID
  - Bridge
  - Composite
    Component
    Leaf
    Composite
  - Decorator
  - Facade
  - Flyweight
  - Proxy
  These patterns deal with ways to define realtions between classes or objects
  - Concerned with how classes and objects are composed to form larger structures

 
  4- Behavioral patterns: 11
   - Chain of Responsibility
   - Command
   - Interpreter
   - Iterator
   - Mediator
   - Memento
   - Observer
   - Sate
   - Strategy - 5 SOLID
   - Template method
   - Visitor
   These patterns deal with ways to communicate between classes or objects
   -Characterize complex control flow tha's difficult to follow at runtime
   - Let you concentrate on the way objects are interconnected


   *Builder Design Pattern and Fluent Builder
      O padrão de desenho Builder é um padrão de 
      desenho criativo que nos permite criar um 
      objecto um passo de cada vez. É bastante 
      comum utilizar este padrão quando se 
      cria um objecto complexo. Utilizando este padrão,
      podemos criar diferentes partes de um objecto, passo a passo, 
      e depois ligar todas as partes em conjunto.
      1- Builder --> Interface, contém method que retorna interface name
      2- Product  --> Class base
      3- ConcreteBuilder  --> Class que implementa interface
      4- Diretor  --> class para construir objecto, usando interface injecção de dependecia no constructor
   *Fluent Builder Interface With Recursive Generics : Creational constructor abstract Inheritance
   *Faceted Builder : Creational constructor abstract Inheritance
   *Factory Method : Creational

   *Singleton
   *Adapter
   *Composite
   *Decorator
   *Command
   *Strategy
   *Facade
   *Visitor
   *Observer
  
 1-  Program to an interface, Not an implementation
     -Abstract class
     -Interfcae

 2- Favor object composition over class inheritance
   - inheritance
   - composition


   INTERFACE VS ABSTRACT CLASS
   The short answer: An abstract class allows you 
   to create functionality that subclasses can implement
   or override. An interface only allows you to define 
   functionality,
   not implement it.
 ______________________________________________________

 Security API (Header->Body)

 -Token
 -Validate
 -Authenticat
 -Auttorizate
 -Post api/login (username/password)


 Doc API Authentication:
 Http bearer, basic
 API keys
 OAth2
 OpenId Connect


 Security:
 Cost
 Unnecessary
 Liability
 Ineffective

 ____________________________________________________________
 Unit Testing:
 -Assert
 -StringAssert
 -CollectionAssert

  -MSTesteing
  -Unit
  --AAA Arrange act assert

  Attribute:
      Grouping: Owner, priority,test,category
      Action: Datarow,Deployment,item,ignore,timeout
      Informational: description
      Data-Driven:Datasource

Assert:
  Positive:
      AreEqual --> string
      AreSome --> object
      IsTrue
      IsInstanceTypeOf --> instance typeof
      IsNull
      NotNull
 Negative:
      AreNotEqual
      AreNotSome
      IsFlase
      IsNotInstanceTypeOf
      IsNotNull
      Null
 Other:
  Fail
  Inconclusive


StringAssert:
  RegEx: Matches, DoesNotMatch
  Contains: Contains
  Starts/Ends with: StartsWith EndsWith

CollectionAssert:
  Equalty:AreEqual, AreNotEqual, must be in the same order
  Equivalency: AreEquivalent, AreNotEquivalent, can be in any order
  Comparer: for object collections

  subet: IsSubsetOf,IsNotSubsetof
  Contains:contains, DoesNotcotain
  Collection:AllItemsAreInstancesOftyoe, AllItemsAreUnique, AllItemAreNotNull

  XUnit:
   Fact: sem paramter
   Theory: com parameter --> skip
   InlineData: put value
   Trait: em group
 ___________________________________________________________
 Refactoring: code clean, code smells
  SOLID
  DDD
  Design patterns

  Refactoring toward cleaner code:
      1- Remove duplication
      2- Improve Naming
      3- Break up large code elements
      4- Reduce coupling
      5- Reduce complexity
      6- Split responsibility (Solid-1)

 Code smell:
  Principle of least astonishment
  Be simple
  Be clear
  Be consistent

  1-Bloaters
  2-Object oritation abusers
  3-Change preventers
  4-Dispensables
  5-Couplers
  6-Obfuscators

  Statement smells:
     Primative obsession:
      Method assinatures: static, enums, primative
      Inconsistency
      Ideal naming characteristtics
      Nome de variavel e metodo como deve ser
      Nome curto e explicto
      - AddItem, AppendItem
      - Criar um contrutor
      - Não abreviar nome
      - if else, switch not use
      - Temporal coupling, abstract and contructor

  Method smells:
   Extract method
   Compose method
   Replace nested conditional with guard clause
   Command
   Visitor
   Stractagecy

  Class smells:

 ________________________________________________________
 TDD:
     Web:
     Core: Libary, tests
     Data:

 -Getting started with test driven develipment
 -Testing and implementing business logic
 -Adding features in an ASP.NET Core 


 Cycle TDD:
   Red: Write a failing test
   Green: Write code to pass the test
   Refactor:

   Test Class:
    - class test main
    - class processor --> core
    - class request -> domain
    - class result -> domain

   Requirements: Mocks,Bussines logic, 
    1- Return result with request values
    2- Throw exception if request is null
    3- Save a desk booking
       Know how to decouple dependencies
       Solid 1; DIP;
    4- Check if a desk is available
    5- Store the desk id on the booking
    6- Return sucess or nodeskAvailable result code
    7- Set the desk bookin id on the result

 _______________________________________________________
 SQL
 Services
 Applications
 Libraries
 SSMS
 SQLCMD --> PowerShell
 Pile of Data
 SQL Server profiler


 __________________________________________________
 DDD: Domain driven design

 -Filosofia voltada para o domínio do negócio 

 -Camada
       <- Application ->
 Domain         <-    Service ->
     <-   Infrastructure

 -Application: Controllador e serviços de API Comunica(Domain,Service)
 -Domain:Classes, Modelos,Interface,const,DTOs, Enums Entity
 -Serviço:Validações,Logic   Comunica(Domain,Infrastructure)
 -Infraestrutura: sub-camadas,  Comunica(Domain)
              Data: BaseDate ORM
              Cross-Cutting:Security,Validate,Comunication extern


Null: Ardalis
Mapper: Mapster, Dapper, AutoMapper
Clean code: CleanUp
_____________________________________________
What are the 4 basic principles of OOP?
the 4 basics of OOP are encapsulation, abstraction, inheritance, and polymorphism

____________________________________
Ajuda para criar objecto imutavel

ImmutableSortedSet
ImmutableSortedDictionary
ObjectPool

Randon
Range
Enumerable
_________________________________
C# Design Patterns – Faceted Builder
1- Create a class Car
2- Create a class Builder: Constroctor - instancia object car
3- Create a class Info: inherict Builder, constructor(Car), all methed afecta propert e return class
_____________________________________________________________________________
TEST:
What we are going to cover is the testing process for 

Model 
Controller 
Classes, 
Integration tests,
Automated UI tests
xUnit --> libary

Unit Testing with xUnit in ASP.NET Core MVC
Testing Controllers with Unit Tests and Moq in ASP.NET Core
Integration Testing in ASP.NET Core
How to Include AntiForgeryToken for MVC Integration Testing
Automated UI tests with Selenium and ASP.NET Core

DTO vs POCO
Now, we are going to create some use cases in .NET Web API project to learn how we can use DTOs and POCOs.

Usage of POCOs
POCOs are frequently used as DDD (Domain Driven Design) entities to model state and behavior. With that, let’s create a domain folder inside our project with a new class:

The main conclusion is that DTOs should be used only for transferring data, 
without any logic or behavior. On the other hand, we should use POCOs to describe the behavior of our object without any third-party dependencies. By their definitions, 
all DTOs should be POCOs, because if a class is not a POCO, it cannot be a valid DTO. That said, we can see why developers confuse these two types.



Generic Constraint:
where T: struct
where T: class
where T: vendor
where T: IVendor
where T: new()

IEnumerable<T> --> GetEnumerator
ICollection<T> 
IList<T>
IDictionary<T,V>


Events, EventArgs<T>
Delegates
Predicate<T>
Action<T>
Func<T>

Event:

Event Handler--> EventArgs --> Delegate

Delegate: Method, Target, GetInvocationList()